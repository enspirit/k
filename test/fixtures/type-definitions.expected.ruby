->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_X = method(:p_string); X = ->(v) { p_unwrap(_p_X.call(v, '')) }; X.call("hello")) == "hello"; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_X = method(:p_int); X = ->(v) { p_unwrap(_p_X.call(v, '')) }; X.call("42")) == 42; true) }.call
->() { def p_any(v, p) p_ok(v, p) end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_X = method(:p_any); X = ->(v) { p_unwrap(_p_X.call(v, '')) }; X.call("anything")) == "anything"; true) }.call
->() { def p_any(v, p) p_ok(v, p) end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_X = method(:p_any); X = ->(v) { p_unwrap(_p_X.call(v, '')) }; X.call(123)) == 123; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _ks = [:name]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Alice"})) == {name: "Alice"}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _r_age = (method(:p_int)).call(v[:age], p + '.age'); return p_fail(p, nil, [_r_age]) unless _r_age[:success]; _o[:age] = _r_age[:value]; _ks = [:name, :age]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Bob", age: "30"})) == {name: "Bob", age: 30}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Empty = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; ; _ks = []; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Empty = ->(v) { p_unwrap(_p_Empty.call(v, '')) }; Empty.call({})) == {}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_PosInt = ->(v, p) { _r = (method(:p_int)).call(v, p); return _r unless _r[:success]; i = _r[:value]; return p_fail(p, 'constraint violated') unless (i > 0); _r }; PosInt = ->(v) { p_unwrap(_p_PosInt.call(v, '')) }; PosInt.call("42")) == 42; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Ints = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = method(:p_int); _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Ints = ->(v) { p_unwrap(_p_Ints.call(v, '')) }; Ints.call(["1", "2", "3"])) == [1, 2, 3]; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Strings = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = method(:p_string); _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Strings = ->(v) { p_unwrap(_p_Strings.call(v, '')) }; Strings.call(["a", "b"])) == ["a", "b"]; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_People = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _ks = [:name]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; People = ->(v) { p_unwrap(_p_People.call(v, '')) }; People.call([{name: "Alice"}, {name: "Bob"}])) == [{name: "Alice"}, {name: "Bob"}]; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call("42")) == 42; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call("hello")) == "hello"; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { _causes = []; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call("42")) == "42"; true) }.call
->() { def p_bool(v, p); return p_ok(v, p) if v == true || v == false; return p_ok(true, p) if v == 'true'; return p_ok(false, p) if v == 'false'; p_fail(p, "expected Bool, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_bool)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call(true)) == true; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = ->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }; _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call(["1", "hello", "3"])) == [1, "hello", 3]; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_age = (->(v, p) { _r = (method(:p_int)).call(v, p); return _r unless _r[:success]; i = _r[:value]; return p_fail(p, 'constraint violated') unless (i > 10); _r }).call(v[:age], p + '.age'); return p_fail(p, nil, [_r_age]) unless _r_age[:success]; _o[:age] = _r_age[:value]; _ks = [:age]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({age: 11})) == {age: 11}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; unless v[:nickname].nil?; _r_nickname = (method(:p_string)).call(v[:nickname], p + '.nickname'); return p_fail(p, nil, [_r_nickname]) unless _r_nickname[:success]; _o[:nickname] = _r_nickname[:value]; end; _ks = [:name, :nickname]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Alice"})) == {name: "Alice"}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; unless v[:nickname].nil?; _r_nickname = (method(:p_string)).call(v[:nickname], p + '.nickname'); return p_fail(p, nil, [_r_nickname]) unless _r_nickname[:success]; _o[:nickname] = _r_nickname[:value]; end; _ks = [:name, :nickname]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Bob", nickname: "Bobby"})) == {name: "Bob", nickname: "Bobby"}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; unless v[:age].nil?; _r_age = (method(:p_int)).call(v[:age], p + '.age'); return p_fail(p, nil, [_r_age]) unless _r_age[:success]; _o[:age] = _r_age[:value]; end; _ks = [:name, :age]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Eve", age: "25"})) == {name: "Eve", age: 25}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_X = method(:p_int); X = ->(v) { p_unwrap(_p_X.call(v, '')) }; X.call("bad")) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _ks = [:name]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call("not-an-object")) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _ks = [:name]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call(nil)) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_PosInt = ->(v, p) { _r = (method(:p_int)).call(v, p); return _r unless _r[:success]; i = _r[:value]; return p_fail(p, 'constraint violated') unless (i > 0); _r }; PosInt = ->(v) { p_unwrap(_p_PosInt.call(v, '')) }; PosInt.call("-5")) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Ints = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = method(:p_int); _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Ints = ->(v) { p_unwrap(_p_Ints.call(v, '')) }; Ints.call(["1", "bad", "3"])) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_T = ->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call(true)) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_age = (->(v, p) { _r = (method(:p_int)).call(v, p); return _r unless _r[:success]; i = _r[:value]; return p_fail(p, 'constraint violated') unless (i > 10); _r }).call(v[:age], p + '.age'); return p_fail(p, nil, [_r_age]) unless _r_age[:success]; _o[:age] = _r_age[:value]; _ks = [:age]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({age: 10})) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; unless v[:age].nil?; _r_age = (method(:p_int)).call(v[:age], p + '.age'); return p_fail(p, nil, [_r_age]) unless _r_age[:success]; _o[:age] = _r_age[:value]; end; _ks = [:name, :age]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Eve", age: "bad"})) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call


->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _ks = [:name]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Alice", extra: "bad"})) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; ; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Alice", extra: "ignored"})) == {name: "Alice"}; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _ks = [:name]; _ep = method(:p_int); v.each_key { |_k| unless _ks.include?(_k); _re = _ep.call(v[_k], p + '.' + _k.to_s); return p_fail(p, nil, [_re]) unless _re[:success]; _o[_k] = _re[:value]; end }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Alice", age: "30", score: "100"})) == {name: "Alice", age: 30, score: 100}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _ks = [:name]; _ep = method(:p_int); v.each_key { |_k| unless _ks.include?(_k); _re = _ep.call(v[_k], p + '.' + _k.to_s); return p_fail(p, nil, [_re]) unless _re[:success]; _o[_k] = _re[:value]; end }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; Person.call({name: "Alice", bad: "not-int"})) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Scores = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; ; _ks = []; _ep = method(:p_int); v.each_key { |_k| unless _ks.include?(_k); _re = _ep.call(v[_k], p + '.' + _k.to_s); return p_fail(p, nil, [_re]) unless _re[:success]; _o[_k] = _re[:value]; end }; p_ok(_o, p) }; Scores = ->(v) { p_unwrap(_p_Scores.call(v, '')) }; Scores.call({a: "1", b: "2"})) == {a: 1, b: 2}; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Open = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; ; ; p_ok(_o, p) }; Open = ->(v) { p_unwrap(_p_Open.call(v, '')) }; Open.call({a: 1, b: "two"})) == {}; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_A = method(:p_string); A = ->(v) { p_unwrap(_p_A.call(v, '')) }; (_p_B = method(:p_int); B = ->(v) { p_unwrap(_p_B.call(v, '')) }; B.call("42"))) == 42; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_A = method(:p_string); A = ->(v) { p_unwrap(_p_A.call(v, '')) }; (_p_B = method(:p_int); B = ->(v) { p_unwrap(_p_B.call(v, '')) }; A.call("hello"))) == "hello"; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Person = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_name = (method(:p_string)).call(v[:name], p + '.name'); return p_fail(p, nil, [_r_name]) unless _r_name[:success]; _o[:name] = _r_name[:value]; _r_age = (->(v, p) { _r = (method(:p_int)).call(v, p); return _r unless _r[:success]; i = _r[:value]; return p_fail(p, 'constraint violated') unless (i > 0); _r }).call(v[:age], p + '.age'); return p_fail(p, nil, [_r_age]) unless _r_age[:success]; _o[:age] = _r_age[:value]; _ks = [:name, :age]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Person = ->(v) { p_unwrap(_p_Person.call(v, '')) }; (_p_Persons = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = _p_Person; _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Persons = ->(v) { p_unwrap(_p_Persons.call(v, '')) }; Persons.call([{name: "Bernard", age: "18"}, {name: "Louis", age: "10"}]))) == [{name: "Bernard", age: 18}, {name: "Louis", age: 10}]; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Item = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_id = (method(:p_int)).call(v[:id], p + '.id'); return p_fail(p, nil, [_r_id]) unless _r_id[:success]; _o[:id] = _r_id[:value]; _ks = [:id]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Item = ->(v) { p_unwrap(_p_Item.call(v, '')) }; (_p_Items = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = _p_Item; _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Items = ->(v) { p_unwrap(_p_Items.call(v, '')) }; Items.call([{id: "1"}, {id: "2"}]))) == [{id: 1}, {id: 2}]; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = method(:p_int); T = ->(v) { p_unwrap(_p_T.call(v, '')) }; (x = 5; x * 2)) == 10; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = method(:p_int); T = ->(v) { p_unwrap(_p_T.call(v, '')) }; (x = 5; y = 3; x + y)) == 8; true) }.call



->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Ints = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = method(:p_int); _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Ints = ->(v) { p_unwrap(_p_Ints.call(v, '')) }; Ints.call([])) == []; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_float(v, p); return p_ok(v, p) if v.is_a?(Numeric); return p_ok(Float(v), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Float, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = method(:p_float); T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call("3.14")) == 3.14; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_float(v, p); return p_ok(v, p) if v.is_a?(Numeric); return p_ok(Float(v), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Float, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = method(:p_float); T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call(42)) == 42; true) }.call

->() { def p_bool(v, p); return p_ok(v, p) if v == true || v == false; return p_ok(true, p) if v == 'true'; return p_ok(false, p) if v == 'false'; p_fail(p, "expected Bool, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Config = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_enabled = (method(:p_bool)).call(v[:enabled], p + '.enabled'); return p_fail(p, nil, [_r_enabled]) unless _r_enabled[:success]; _o[:enabled] = _r_enabled[:value]; _ks = [:enabled]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Config = ->(v) { p_unwrap(_p_Config.call(v, '')) }; Config.call({enabled: "true"})) == {enabled: true}; true) }.call
->() { def p_bool(v, p); return p_ok(v, p) if v == true || v == false; return p_ok(true, p) if v == 'true'; return p_ok(false, p) if v == 'false'; p_fail(p, "expected Bool, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Config = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_enabled = (method(:p_bool)).call(v[:enabled], p + '.enabled'); return p_fail(p, nil, [_r_enabled]) unless _r_enabled[:success]; _o[:enabled] = _r_enabled[:value]; _ks = [:enabled]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Config = ->(v) { p_unwrap(_p_Config.call(v, '')) }; Config.call({enabled: "false"})) == {enabled: false}; true) }.call

->() { def p_datetime(v, p); return p_ok(v, p) if v.is_a?(DateTime) || v.is_a?(Time); return p_ok(DateTime.parse(v), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Datetime, got #{v.nil? ? 'Null' : v.is_a?(String) ? 'invalid datetime ' + v.inspect : v.class}") end; def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_Event = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_date = (method(:p_datetime)).call(v[:date], p + '.date'); return p_fail(p, nil, [_r_date]) unless _r_date[:success]; _o[:date] = _r_date[:value]; _ks = [:date]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; Event = ->(v) { p_unwrap(_p_Event.call(v, '')) }; Event.call({date: "2024-01-15T10:30:00"})[:date].year) == 2024; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_a = (->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_b = (->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_c = (method(:p_int)).call(v[:c], p + '.c'); return p_fail(p, nil, [_r_c]) unless _r_c[:success]; _o[:c] = _r_c[:value]; _ks = [:c]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }).call(v[:b], p + '.b'); return p_fail(p, nil, [_r_b]) unless _r_b[:success]; _o[:b] = _r_b[:value]; _ks = [:b]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }).call(v[:a], p + '.a'); return p_fail(p, nil, [_r_a]) unless _r_a[:success]; _o[:a] = _r_a[:value]; _ks = [:a]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call({a: {b: {c: "42"}}})) == {a: {b: {c: 42}}}; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; unless v[:value].nil?; _r_value = (->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }).call(v[:value], p + '.value'); return p_fail(p, nil, [_r_value]) unless _r_value[:success]; _o[:value] = _r_value[:value]; end; _ks = [:value]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call({value: "42"})) == {value: 42}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; unless v[:value].nil?; _r_value = (->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }).call(v[:value], p + '.value'); return p_fail(p, nil, [_r_value]) unless _r_value[:success]; _o[:value] = _r_value[:value]; end; _ks = [:value]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call({value: "hello"})) == {value: "hello"}; true) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_string(v, p); return p_ok(v, p) if v.is_a?(String); p_fail(p, "expected String, got #{v.nil? ? 'Null' : v.class}") end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; unless v[:value].nil?; _r_value = (->(v, p) { _causes = []; _r = (method(:p_int)).call(v, p); return _r if _r[:success]; _causes << _r; _r = (method(:p_string)).call(v, p); return _r if _r[:success]; _causes << _r; p_fail(p, 'no union alternative matched', _causes) }).call(v[:value], p + '.value'); return p_fail(p, nil, [_r_value]) unless _r_value[:success]; _o[:value] = _r_value[:value]; end; _ks = [:value]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call({})) == {}; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_NonNeg = ->(v, p) { _r = (method(:p_int)).call(v, p); return _r unless _r[:success]; i = _r[:value]; return p_fail(p, 'constraint violated') unless (i >= 0); _r }; NonNeg = ->(v) { p_unwrap(_p_NonNeg.call(v, '')) }; NonNeg.call("0")) == 0; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (raise "Assertion failed" unless (_p_T = ->(v, p) { return p_fail(p, 'expected object, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Hash); _o = {}; _r_x1 = (method(:p_int)).call(v[:x1], p + '.x1'); return p_fail(p, nil, [_r_x1]) unless _r_x1[:success]; _o[:x1] = _r_x1[:value]; _r_x2 = (method(:p_int)).call(v[:x2], p + '.x2'); return p_fail(p, nil, [_r_x2]) unless _r_x2[:success]; _o[:x2] = _r_x2[:value]; _ks = [:x1, :x2]; v.each_key { |_k| return p_fail(p + '.' + _k.to_s, 'unexpected attribute') unless _ks.include?(_k) }; p_ok(_o, p) }; T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call({x1: "1", x2: "2"})) == {x1: 1, x2: 2}; true) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Ints = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = method(:p_int); _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Ints = ->(v) { p_unwrap(_p_Ints.call(v, '')) }; Ints.call([nil])) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_int(v, p); return p_ok(v, p) if v.is_a?(Integer); return p_ok(Integer(v, 10), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Int, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_Ints = ->(v, p) { return p_fail(p, 'expected array, got ' + (v.nil? ? 'Null' : v.class.to_s)) unless v.is_a?(Array); _el = method(:p_int); _a = []; v.each_with_index { |_e, _i| _r = _el.call(_e, p + '.' + _i.to_s); return p_fail(p, nil, [_r]) unless _r[:success]; _a << _r[:value] }; p_ok(_a, p) }; Ints = ->(v) { p_unwrap(_p_Ints.call(v, '')) }; Ints.call(["1", nil, "3"])) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call

->() { def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_float(v, p); return p_ok(v, p) if v.is_a?(Numeric); return p_ok(Float(v), p) if v.is_a?(String) rescue nil; p_fail(p, "expected Float, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_T = method(:p_float); T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call("bad")) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call

->() { def p_bool(v, p); return p_ok(v, p) if v == true || v == false; return p_ok(true, p) if v == 'true'; return p_ok(false, p) if v == 'false'; p_fail(p, "expected Bool, got #{v.nil? ? 'Null' : v.is_a?(String) ? v.inspect : v.class}") end; def p_fail(p, m = nil, c = nil) { success: false, path: p, message: m || '', value: nil, cause: c || [] } end; def p_ok(v, p) { success: true, path: p, message: '', value: v, cause: [] } end; def p_unwrap(r); return r[:value] if r[:success]; find_error = ->(e) {; return e if e[:message] && !e[:message].empty?; return find_error.call(e[:cause][0]) if e[:cause] && e[:cause][0]; e; }; err = find_error.call(r); raise "#{err[:path] || '.'}: #{err[:message] || 'type error'}" end; (begin; (->() { (_p_T = method(:p_bool); T = ->(v) { p_unwrap(_p_T.call(v, '')) }; T.call("bad")) }).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call
