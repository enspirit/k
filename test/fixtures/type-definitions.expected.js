(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_X = pString; const X = (v) => pUnwrap(_p_X(v, '')); return X("hello"); })(), "hello"))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_X = pInt; const X = (v) => pUnwrap(_p_X(v, '')); return X("42"); })(), 42))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_X = pInt; const X = (v) => pUnwrap(_p_X(v, '')); return X("bad"); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pAny(v, p) { return pOk(v, p); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_X = pAny; const X = (v) => pUnwrap(_p_X(v, '')); return X("anything"); })(), "anything"))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pAny(v, p) { return pOk(v, p); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_X = pAny; const X = (v) => pUnwrap(_p_X(v, '')); return X(123); })(), 123))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, []); const _o = {}; const _r_name = pString(v.name, p + '.name'); if (!_r_name.success) return pFail(p, [_r_name]); _o.name = _r_name.value; return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Alice"})); })(), ({name: "Alice"})))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, []); const _o = {}; const _r_name = pString(v.name, p + '.name'); if (!_r_name.success) return pFail(p, [_r_name]); _o.name = _r_name.value; const _r_age = pInt(v.age, p + '.age'); if (!_r_age.success) return pFail(p, [_r_age]); _o.age = _r_age.value; return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Bob", age: "30"})); })(), ({name: "Bob", age: 30})))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, []); const _o = {}; const _r_name = pString(v.name, p + '.name'); if (!_r_name.success) return pFail(p, [_r_name]); _o.name = _r_name.value; const _r_age = pInt(v.age, p + '.age'); if (!_r_age.success) return pFail(p, [_r_age]); _o.age = _r_age.value; return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Eve", age: "bad"})); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, []); const _o = {}; const _r_name = pString(v.name, p + '.name'); if (!_r_name.success) return pFail(p, [_r_name]); _o.name = _r_name.value; return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person("not-an-object"); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, []); const _o = {}; const _r_name = pString(v.name, p + '.name'); if (!_r_name.success) return pFail(p, [_r_name]); _o.name = _r_name.value; return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(null); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Empty = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, []); const _o = {};  return pOk(_o, p); }; const Empty = (v) => pUnwrap(_p_Empty(v, '')); return Empty(({})); })(), ({})))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_PosInt = (v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 0)) return pFail(p, []); return _r; }; const PosInt = (v) => pUnwrap(_p_PosInt(v, '')); return PosInt("42"); })(), 42))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_PosInt = (v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 0)) return pFail(p, []); return _r; }; const PosInt = (v) => pUnwrap(_p_PosInt(v, '')); return PosInt("-5"); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_PosInt = (v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 0)) return pFail(p, []); return _r; }; const PosInt = (v) => pUnwrap(_p_PosInt(v, '')); return PosInt("bad"); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, []); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '[' + _i + ']'); if (!_r.success) return pFail(p, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints(["1", "2", "3"]); })(), [1, 2, 3]))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, []); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '[' + _i + ']'); if (!_r.success) return pFail(p, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints(["1", "bad", "3"]); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, []); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '[' + _i + ']'); if (!_r.success) return pFail(p, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints("not-array"); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_Strings = (v, p) => { if (!Array.isArray(v)) return pFail(p, []); const _el = pString; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '[' + _i + ']'); if (!_r.success) return pFail(p, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Strings = (v) => pUnwrap(_p_Strings(v, '')); return Strings(["a", "b"]); })(), ["a", "b"]))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_People = (v, p) => { if (!Array.isArray(v)) return pFail(p, []); const _el = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, []); const _o = {}; const _r_name = pString(v.name, p + '.name'); if (!_r_name.success) return pFail(p, [_r_name]); _o.name = _r_name.value; return pOk(_o, p); }; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '[' + _i + ']'); if (!_r.success) return pFail(p, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const People = (v) => pUnwrap(_p_People(v, '')); return People([({name: "Alice"}), ({name: "Bob"})]); })(), [({name: "Alice"}), ({name: "Bob"})]))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; _r = (pInt)(v, p); if (_r.success) return _r; _r = (pString)(v, p); if (_r.success) return _r; return pFail(p, []); }; const T = (v) => pUnwrap(_p_T(v, '')); return T("42"); })(), 42))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; _r = (pInt)(v, p); if (_r.success) return _r; _r = (pString)(v, p); if (_r.success) return _r; return pFail(p, []); }; const T = (v) => pUnwrap(_p_T(v, '')); return T("hello"); })(), "hello"))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; _r = (pString)(v, p); if (_r.success) return _r; _r = (pInt)(v, p); if (_r.success) return _r; return pFail(p, []); }; const T = (v) => pUnwrap(_p_T(v, '')); return T("42"); })(), "42"))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; _r = (pInt)(v, p); if (_r.success) return _r; _r = (pString)(v, p); if (_r.success) return _r; return pFail(p, []); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(true); })(), null))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, []); } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; _r = (pInt)(v, p); if (_r.success) return _r; _r = (pString)(v, p); if (_r.success) return _r; _r = (pBool)(v, p); if (_r.success) return _r; return pFail(p, []); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(true); })(), true))) throw new Error("Assertion failed"); return true; })(); })()
(function() { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, c) { return { success: false, path: p, value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, []); } function pOk(v, p) { return { success: true, path: p, value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, []); } function pUnwrap(r) { return r.success ? r.value : null; } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { if (!Array.isArray(v)) return pFail(p, []); const _el = (v, p) => { let _r; _r = (pInt)(v, p); if (_r.success) return _r; _r = (pString)(v, p); if (_r.success) return _r; return pFail(p, []); }; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '[' + _i + ']'); if (!_r.success) return pFail(p, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(["1", "hello", "3"]); })(), [1, "hello", 3]))) throw new Error("Assertion failed"); return true; })(); })()
