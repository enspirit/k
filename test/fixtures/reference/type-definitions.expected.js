(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_X = pString; const X = (v) => pUnwrap(_p_X(v, '')); return X("hello"); })(), "hello"))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_X = pInt; const X = (v) => pUnwrap(_p_X(v, '')); return X("42"); })(), 42))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pAny(v, p) { return pOk(v, p); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_X = pAny; const X = (v) => pUnwrap(_p_X(v, '')); return X("anything"); })(), "anything"))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pAny(v, p) { return pOk(v, p); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_X = pAny; const X = (v) => pUnwrap(_p_X(v, '')); return X(123); })(), 123))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _ks = ["name"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Alice"})); })(), ({name: "Alice"})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _r_age = (pInt)(v.age, p + '.age'); if (!_r_age.success) return pFail(p, null, [_r_age]); _o.age = _r_age.value; const _ks = ["name","age"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Bob", age: "30"})); })(), ({name: "Bob", age: 30})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Empty = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {};  const _ks = []; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Empty = (v) => pUnwrap(_p_Empty(v, '')); return Empty(({})); })(), ({})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_PosInt = (v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 0)) return pFail(p, 'constraint violated'); return _r; }; const PosInt = (v) => pUnwrap(_p_PosInt(v, '')); return PosInt("42"); })(), 42))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints(["1", "2", "3"]); })(), [1, 2, 3]))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Strings = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = pString; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Strings = (v) => pUnwrap(_p_Strings(v, '')); return Strings(["a", "b"]); })(), ["a", "b"]))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_People = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _ks = ["name"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const People = (v) => pUnwrap(_p_People(v, '')); return People([({name: "Alice"}), ({name: "Bob"})]); })(), [({name: "Alice"}), ({name: "Bob"})]))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); }; const T = (v) => pUnwrap(_p_T(v, '')); return T("42"); })(), 42))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); }; const T = (v) => pUnwrap(_p_T(v, '')); return T("hello"); })(), "hello"))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; const _causes = []; _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); }; const T = (v) => pUnwrap(_p_T(v, '')); return T("42"); })(), "42"))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, 'expected Bool, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pBool)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(true); })(), true))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = (v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); }; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(["1", "hello", "3"]); })(), [1, "hello", 3]))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_age = ((v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 10)) return pFail(p, 'constraint violated'); return _r; })(v.age, p + '.age'); if (!_r_age.success) return pFail(p, null, [_r_age]); _o.age = _r_age.value; const _ks = ["age"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({age: 11})); })(), ({age: 11})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; if (v.nickname != null) { const _r_nickname = (pString)(v.nickname, p + '.nickname'); if (!_r_nickname.success) return pFail(p, null, [_r_nickname]); _o.nickname = _r_nickname.value; } const _ks = ["name","nickname"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Alice"})); })(), ({name: "Alice"})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; if (v.nickname != null) { const _r_nickname = (pString)(v.nickname, p + '.nickname'); if (!_r_nickname.success) return pFail(p, null, [_r_nickname]); _o.nickname = _r_nickname.value; } const _ks = ["name","nickname"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Bob", nickname: "Bobby"})); })(), ({name: "Bob", nickname: "Bobby"})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; if (v.age != null) { const _r_age = (pInt)(v.age, p + '.age'); if (!_r_age.success) return pFail(p, null, [_r_age]); _o.age = _r_age.value; } const _ks = ["name","age"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Eve", age: "25"})); })(), ({name: "Eve", age: 25})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_X = pInt; const X = (v) => pUnwrap(_p_X(v, '')); return X("bad"); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _ks = ["name"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person("not-an-object"); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _ks = ["name"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(null); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_PosInt = (v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 0)) return pFail(p, 'constraint violated'); return _r; }; const PosInt = (v) => pUnwrap(_p_PosInt(v, '')); return PosInt("-5"); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints(["1", "bad", "3"]); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_T = (v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(true); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_age = ((v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 10)) return pFail(p, 'constraint violated'); return _r; })(v.age, p + '.age'); if (!_r_age.success) return pFail(p, null, [_r_age]); _o.age = _r_age.value; const _ks = ["age"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({age: 10})); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; if (v.age != null) { const _r_age = (pInt)(v.age, p + '.age'); if (!_r_age.success) return pFail(p, null, [_r_age]); _o.age = _r_age.value; } const _ks = ["name","age"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Eve", age: "bad"})); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);


(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _ks = ["name"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Alice", extra: "bad"})); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value;  return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Alice", extra: "ignored"})); })(), ({name: "Alice"})))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _ks = ["name"]; const _ep = pInt; for (const _k in v) { if (!_ks.includes(_k)) { const _re = _ep(v[_k], p + '.' + _k); if (!_re.success) return pFail(p, null, [_re]); _o[_k] = _re.value; } } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Alice", age: "30", score: "100"})); })(), ({name: "Alice", age: 30, score: 100})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _ks = ["name"]; const _ep = pInt; for (const _k in v) { if (!_ks.includes(_k)) { const _re = _ep(v[_k], p + '.' + _k); if (!_re.success) return pFail(p, null, [_re]); _o[_k] = _re.value; } } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return Person(({name: "Alice", bad: "not-int"})); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Scores = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {};  const _ks = []; const _ep = pInt; for (const _k in v) { if (!_ks.includes(_k)) { const _re = _ep(v[_k], p + '.' + _k); if (!_re.success) return pFail(p, null, [_re]); _o[_k] = _re.value; } } return pOk(_o, p); }; const Scores = (v) => pUnwrap(_p_Scores(v, '')); return Scores(({a: "1", b: "2"})); })(), ({a: 1, b: 2})))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Open = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {};   return pOk(_o, p); }; const Open = (v) => pUnwrap(_p_Open(v, '')); return Open(({a: 1, b: "two"})); })(), ({})))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_A = pString; const A = (v) => pUnwrap(_p_A(v, '')); return (() => { const _p_B = pInt; const B = (v) => pUnwrap(_p_B(v, '')); return B("42"); })(); })(), 42))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_A = pString; const A = (v) => pUnwrap(_p_A(v, '')); return (() => { const _p_B = pInt; const B = (v) => pUnwrap(_p_B(v, '')); return A("hello"); })(); })(), "hello"))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Person = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_name = (pString)(v.name, p + '.name'); if (!_r_name.success) return pFail(p, null, [_r_name]); _o.name = _r_name.value; const _r_age = ((v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i > 0)) return pFail(p, 'constraint violated'); return _r; })(v.age, p + '.age'); if (!_r_age.success) return pFail(p, null, [_r_age]); _o.age = _r_age.value; const _ks = ["name","age"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Person = (v) => pUnwrap(_p_Person(v, '')); return (() => { const _p_Persons = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = _p_Person; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Persons = (v) => pUnwrap(_p_Persons(v, '')); return Persons([({name: "Bernard", age: "18"}), ({name: "Louis", age: "10"})]); })(); })(), [({name: "Bernard", age: 18}), ({name: "Louis", age: 10})]))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Item = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_id = (pInt)(v.id, p + '.id'); if (!_r_id.success) return pFail(p, null, [_r_id]); _o.id = _r_id.value; const _ks = ["id"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Item = (v) => pUnwrap(_p_Item(v, '')); return (() => { const _p_Items = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = _p_Item; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Items = (v) => pUnwrap(_p_Items(v, '')); return Items([({id: "1"}), ({id: "2"})]); })(); })(), [({id: 1}), ({id: 2})]))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!((() => { const _p_T = pInt; const T = (v) => pUnwrap(_p_T(v, '')); return (() => { const x = 5; return x * 2; })(); })() == 10)) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!((() => { const _p_T = pInt; const T = (v) => pUnwrap(_p_T(v, '')); return (() => { const x = 5; const y = 3; return x + y; })(); })() == 8)) throw new Error("Assertion failed"); return true; })(); })(null);



(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints([]); })(), []))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pFloat(v, p) { if (typeof v === 'number') return pOk(v, p); if (typeof v === 'string') { const n = parseFloat(v); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Float, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = pFloat; const T = (v) => pUnwrap(_p_T(v, '')); return T("3.14"); })(), 3.14))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pFloat(v, p) { if (typeof v === 'number') return pOk(v, p); if (typeof v === 'string') { const n = parseFloat(v); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Float, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = pFloat; const T = (v) => pUnwrap(_p_T(v, '')); return T(42); })(), 42))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, 'expected Bool, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Config = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_enabled = (pBool)(v.enabled, p + '.enabled'); if (!_r_enabled.success) return pFail(p, null, [_r_enabled]); _o.enabled = _r_enabled.value; const _ks = ["enabled"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Config = (v) => pUnwrap(_p_Config(v, '')); return Config(({enabled: "true"})); })(), ({enabled: true})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, 'expected Bool, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Config = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_enabled = (pBool)(v.enabled, p + '.enabled'); if (!_r_enabled.success) return pFail(p, null, [_r_enabled]); _o.enabled = _r_enabled.value; const _ks = ["enabled"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Config = (v) => pUnwrap(_p_Config(v, '')); return Config(({enabled: "false"})); })(), ({enabled: false})))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pDatetime(v, p) { if (dayjs.isDayjs(v)) return pOk(v, p); if (typeof v === 'string') { const d = dayjs(v); if (d.isValid()) return pOk(d, p); } return pFail(p, 'expected Datetime, got ' + (v === null ? 'Null' : typeof v === 'string' ? 'invalid datetime ' + JSON.stringify(v) : typeof v)); } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_Event = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_date = (pDatetime)(v.date, p + '.date'); if (!_r_date.success) return pFail(p, null, [_r_date]); _o.date = _r_date.value; const _ks = ["date"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const Event = (v) => pUnwrap(_p_Event(v, '')); return Event(({date: "2024-01-15T10:30:00"})).date.year(); })(), 2024))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_a = ((v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_b = ((v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_c = (pInt)(v.c, p + '.c'); if (!_r_c.success) return pFail(p, null, [_r_c]); _o.c = _r_c.value; const _ks = ["c"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); })(v.b, p + '.b'); if (!_r_b.success) return pFail(p, null, [_r_b]); _o.b = _r_b.value; const _ks = ["b"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); })(v.a, p + '.a'); if (!_r_a.success) return pFail(p, null, [_r_a]); _o.a = _r_a.value; const _ks = ["a"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(({a: ({b: ({c: "42"})})})); })(), ({a: ({b: ({c: 42})})})))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; if (v.value != null) { const _r_value = ((v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); })(v.value, p + '.value'); if (!_r_value.success) return pFail(p, null, [_r_value]); _o.value = _r_value.value; } const _ks = ["value"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(({value: "42"})); })(), ({value: 42})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; if (v.value != null) { const _r_value = ((v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); })(v.value, p + '.value'); if (!_r_value.success) return pFail(p, null, [_r_value]); _o.value = _r_value.value; } const _ks = ["value"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(({value: "hello"})); })(), ({value: "hello"})))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pString(v, p) { if (typeof v === 'string') return pOk(v, p); return pFail(p, 'expected String, got ' + (v === null ? 'Null' : typeof v)); } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; if (v.value != null) { const _r_value = ((v, p) => { let _r; const _causes = []; _r = (pInt)(v, p); if (_r.success) return _r; _causes.push(_r); _r = (pString)(v, p); if (_r.success) return _r; _causes.push(_r); return pFail(p, 'no union alternative matched', _causes); })(v.value, p + '.value'); if (!_r_value.success) return pFail(p, null, [_r_value]); _o.value = _r_value.value; } const _ks = ["value"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(({})); })(), ({})))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_NonNeg = (v, p) => { const _r = pInt(v, p); if (!_r.success) return _r; const i = _r.value; if (!(i >= 0)) return pFail(p, 'constraint violated'); return _r; }; const NonNeg = (v) => pUnwrap(_p_NonNeg(v, '')); return NonNeg("0"); })(), 0))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function kEq(l, r) { if (dayjs.isDuration(l) && dayjs.isDuration(r)) return l.asMilliseconds() === r.asMilliseconds(); if (dayjs.isDayjs(l) && dayjs.isDayjs(r)) return l.valueOf() === r.valueOf(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { if (!(kEq((() => { const _p_T = (v, p) => { if (typeof v !== 'object' || v === null) return pFail(p, 'expected object, got ' + (v === null ? 'Null' : typeof v)); const _o = {}; const _r_x1 = (pInt)(v.x1, p + '.x1'); if (!_r_x1.success) return pFail(p, null, [_r_x1]); _o.x1 = _r_x1.value; const _r_x2 = (pInt)(v.x2, p + '.x2'); if (!_r_x2.success) return pFail(p, null, [_r_x2]); _o.x2 = _r_x2.value; const _ks = ["x1","x2"]; for (const _k in v) { if (!_ks.includes(_k)) return pFail(p + '.' + _k, 'unexpected attribute'); } return pOk(_o, p); }; const T = (v) => pUnwrap(_p_T(v, '')); return T(({x1: "1", x2: "2"})); })(), ({x1: 1, x2: 2})))) throw new Error("Assertion failed"); return true; })(); })(null);

(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints([null]); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pInt(v, p) { if (typeof v === 'number' && Number.isInteger(v)) return pOk(v, p); if (typeof v === 'string') { const n = parseInt(v, 10); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Int, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_Ints = (v, p) => { if (!Array.isArray(v)) return pFail(p, 'expected array, got ' + (v === null ? 'Null' : typeof v)); const _el = pInt; const _a = []; for (let _i = 0; _i < v.length; _i++) { const _r = _el(v[_i], p + '.' + _i); if (!_r.success) return pFail(p, null, [_r]); _a.push(_r.value); } return pOk(_a, p); }; const Ints = (v) => pUnwrap(_p_Ints(v, '')); return Ints(["1", null, "3"]); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);

(function(_) { function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pFloat(v, p) { if (typeof v === 'number') return pOk(v, p); if (typeof v === 'string') { const n = parseFloat(v); if (!isNaN(n)) return pOk(n, p); } return pFail(p, 'expected Float, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_T = pFloat; const T = (v) => pUnwrap(_p_T(v, '')); return T("bad"); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);

(function(_) { function pBool(v, p) { if (typeof v === 'boolean') return pOk(v, p); if (v === 'true') return pOk(true, p); if (v === 'false') return pOk(false, p); return pFail(p, 'expected Bool, got ' + (v === null ? 'Null' : typeof v === 'string' ? JSON.stringify(v) : typeof v)); } function pFail(p, m, c) { return { success: false, path: p, message: m || '', value: null, cause: c || [] }; } function pOk(v, p) { return { success: true, path: p, message: '', value: v, cause: [] }; } function pUnwrap(r) { if (r.success) return r.value; function findError(e) { if (e.message) return e; if (e.cause && e.cause[0]) return findError(e.cause[0]); return e; } const err = findError(r); throw new Error((err.path || '.') + ': ' + (err.message || 'type error')); } return (function() { try { (() => (() => { const _p_T = pBool; const T = (v) => pUnwrap(_p_T(v, '')); return T("bad"); })())(); throw new Error("Expected error but none thrown"); } catch(e) { if (e.message === "Expected error but none thrown") throw e; return true; } })(); })(null);
