assert((let X = String in 'hello' |> X) == 'hello')
assert((let X = Int in '42' |> X) == 42)
assert((let X = . in 'anything' |> X) == 'anything')
assert((let X = Any in 123 |> X) == 123)
assert((let Person = { name: String } in { name: 'Alice' } |> Person) == { name: 'Alice' })
assert((let Person = { name: String, age: Int } in { name: 'Bob', age: '30' } |> Person) == { name: 'Bob', age: 30 })
assert((let Empty = {} in {} |> Empty) == {})
assert((let PosInt = Int(i | i > 0) in '42' |> PosInt) == 42)
assert((let Ints = [Int] in ['1', '2', '3'] |> Ints) == [1, 2, 3])
assert((let Strings = [String] in ['a', 'b'] |> Strings) == ['a', 'b'])
assert((let People = [{ name: String }] in [{ name: 'Alice' }, { name: 'Bob' }] |> People) == [{ name: 'Alice' }, { name: 'Bob' }])
assert((let T = Int|String in '42' |> T) == 42)
assert((let T = Int|String in 'hello' |> T) == 'hello')
assert((let T = String|Int in '42' |> T) == '42')
assert((let T = Int|String|Bool in true |> T) == true)
assert((let T = [Int|String] in ['1', 'hello', '3'] |> T) == [1, 'hello', 3])
assert((let Person = { age: Int(i | i > 10) } in { age: 11 } |> Person) == { age: 11 })
assert((let Person = { name: String, nickname :? String } in { name: 'Alice' } |> Person) == { name: 'Alice' })
assert((let Person = { name: String, nickname :? String } in { name: 'Bob', nickname: 'Bobby' } |> Person) == { name: 'Bob', nickname: 'Bobby' })
assert((let Person = { name: String, age :? Int } in { name: 'Eve', age: '25' } |> Person) == { name: 'Eve', age: 25 })
assertFails(fn( ~> let X = Int in 'bad' |> X ))
assertFails(fn( ~> let Person = { name: String } in 'not-an-object' |> Person ))
assertFails(fn( ~> let Person = { name: String } in null |> Person ))
assertFails(fn( ~> let PosInt = Int(i | i > 0) in '-5' |> PosInt ))
assertFails(fn( ~> let Ints = [Int] in ['1', 'bad', '3'] |> Ints ))
assertFails(fn( ~> let T = Int|String in true |> T ))
assertFails(fn( ~> let Person = { age: Int(i | i > 10) } in { age: 10 } |> Person ))
assertFails(fn( ~> let Person = { name: String, age :? Int } in { name: 'Eve', age: 'bad' } |> Person ))
# Extra attributes tests
# Closed (default): extra attributes not allowed
assertFails(fn( ~> let Person = { name: String } in { name: 'Alice', extra: 'bad' } |> Person ))
# Ignored (...): extra attributes allowed but not in output
assert((let Person = { name: String, ... } in { name: 'Alice', extra: 'ignored' } |> Person) == { name: 'Alice' })
# Typed (...: Type): extra attributes must match type
assert((let Person = { name: String, ...: Int } in { name: 'Alice', age: '30', score: '100' } |> Person) == { name: 'Alice', age: 30, score: 100 })
assertFails(fn( ~> let Person = { name: String, ...: Int } in { name: 'Alice', bad: 'not-int' } |> Person ))
# Open type with just spread and type
assert((let Scores = { ...: Int } in { a: '1', b: '2' } |> Scores) == { a: 1, b: 2 })
# Open type with just spread (ignored)
assert((let Open = { ... } in { a: 1, b: 'two' } |> Open) == {})
# Multiple type bindings
assert((let A = String, B = Int in '42' |> B) == 42)
assert((let A = String, B = Int in 'hello' |> A) == 'hello')
assert((let Person = { name: String, age: Int(i | i > 0) }, Persons = [Person] in [{ name: 'Bernard', age: '18' }, { name: 'Louis', age: '10' }] |> Persons) == [{ name: 'Bernard', age: 18 }, { name: 'Louis', age: 10 }])
assert((let Item = { id: Int }, Items = [Item] in [{ id: '1' }, { id: '2' }] |> Items) == [{ id: 1 }, { id: 2 }])
# Type binding followed by value binding
assert((let T = Int, x = 5 in x * 2) == 10)
assert((let T = Int, x = 5, y = 3 in x + y) == 8)

# Sceptic tests: boundary cases and missing type coverage
# Empty array with typed elements
assert((let Ints = [Int] in [] |> Ints) == [])
# Float type coercion
assert((let T = Float in '3.14' |> T) == 3.14)
assert((let T = Float in 42 |> T) == 42.0)
# Bool type coercion in schema
assert((let Config = { enabled: Bool } in { enabled: 'true' } |> Config) == { enabled: true })
assert((let Config = { enabled: Bool } in { enabled: 'false' } |> Config) == { enabled: false })
# Datetime type coercion in schema
assert((let Event = { date: Datetime } in (({ date: '2024-01-15T10:30:00' } |> Event).date |> year)) == 2024)
# Deeply nested struct schemas
assert((let T = { a: { b: { c: Int } } } in { a: { b: { c: '42' } } } |> T) == { a: { b: { c: 42 } } })
# Optional attribute with union type
assert((let T = { value :? Int|String } in { value: '42' } |> T) == { value: 42 })
assert((let T = { value :? Int|String } in { value: 'hello' } |> T) == { value: 'hello' })
assert((let T = { value :? Int|String } in {} |> T) == {})
# Subtype constraint with edge boundary (>= 0 with value 0)
assert((let NonNeg = Int(i | i >= 0) in '0' |> NonNeg) == 0)
# Property names with numbers
assert((let T = { x1: Int, x2: Int } in { x1: '1', x2: '2' } |> T) == { x1: 1, x2: 2 })
# Null in typed array should fail
assertFails(fn( ~> let Ints = [Int] in [null] |> Ints ))
assertFails(fn( ~> let Ints = [Int] in ['1', null, '3'] |> Ints ))
# Float parsing failure
assertFails(fn( ~> let T = Float in 'bad' |> T ))
# Bool parsing failure
assertFails(fn( ~> let T = Bool in 'bad' |> T ))
