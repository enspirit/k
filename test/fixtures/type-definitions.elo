assert((let X = String in 'hello' |> X) == 'hello')
assert((let X = Int in '42' |> X) == 42)
assert((let X = . in 'anything' |> X) == 'anything')
assert((let X = Any in 123 |> X) == 123)
assert((let Person = { name: String } in { name: 'Alice' } |> Person) == { name: 'Alice' })
assert((let Person = { name: String, age: Int } in { name: 'Bob', age: '30' } |> Person) == { name: 'Bob', age: 30 })
assert((let Empty = {} in {} |> Empty) == {})
assert((let PosInt = Int(i | i > 0) in '42' |> PosInt) == 42)
assert((let Ints = [Int] in ['1', '2', '3'] |> Ints) == [1, 2, 3])
assert((let Strings = [String] in ['a', 'b'] |> Strings) == ['a', 'b'])
assert((let People = [{ name: String }] in [{ name: 'Alice' }, { name: 'Bob' }] |> People) == [{ name: 'Alice' }, { name: 'Bob' }])
assert((let T = Int|String in '42' |> T) == 42)
assert((let T = Int|String in 'hello' |> T) == 'hello')
assert((let T = String|Int in '42' |> T) == '42')
assert((let T = Int|String|Bool in true |> T) == true)
assert((let T = [Int|String] in ['1', 'hello', '3'] |> T) == [1, 'hello', 3])
assert((let Person = { age: Int(i | i > 10) } in { age: 11 } |> Person) == { age: 11 })
assert((let Person = { name: String, nickname :? String } in { name: 'Alice' } |> Person) == { name: 'Alice' })
assert((let Person = { name: String, nickname :? String } in { name: 'Bob', nickname: 'Bobby' } |> Person) == { name: 'Bob', nickname: 'Bobby' })
assert((let Person = { name: String, age :? Int } in { name: 'Eve', age: '25' } |> Person) == { name: 'Eve', age: 25 })
assertFails(fn( ~> let X = Int in 'bad' |> X ))
assertFails(fn( ~> let Person = { name: String } in 'not-an-object' |> Person ))
assertFails(fn( ~> let Person = { name: String } in null |> Person ))
assertFails(fn( ~> let PosInt = Int(i | i > 0) in '-5' |> PosInt ))
assertFails(fn( ~> let Ints = [Int] in ['1', 'bad', '3'] |> Ints ))
assertFails(fn( ~> let T = Int|String in true |> T ))
assertFails(fn( ~> let Person = { age: Int(i | i > 10) } in { age: 10 } |> Person ))
assertFails(fn( ~> let Person = { name: String, age :? Int } in { name: 'Eve', age: 'bad' } |> Person ))
# Extra attributes tests
# Closed (default): extra attributes not allowed
assertFails(fn( ~> let Person = { name: String } in { name: 'Alice', extra: 'bad' } |> Person ))
# Ignored (...): extra attributes allowed but not in output
assert((let Person = { name: String, ... } in { name: 'Alice', extra: 'ignored' } |> Person) == { name: 'Alice' })
# Typed (...: Type): extra attributes must match type
assert((let Person = { name: String, ...: Int } in { name: 'Alice', age: '30', score: '100' } |> Person) == { name: 'Alice', age: 30, score: 100 })
assertFails(fn( ~> let Person = { name: String, ...: Int } in { name: 'Alice', bad: 'not-int' } |> Person ))
# Open type with just spread and type
assert((let Scores = { ...: Int } in { a: '1', b: '2' } |> Scores) == { a: 1, b: 2 })
# Open type with just spread (ignored)
assert((let Open = { ... } in { a: 1, b: 'two' } |> Open) == {})

