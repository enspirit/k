->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({}, [:name], "Alice") == {name: "Alice"}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({name: "Alice"}, [:name], "Bob") == {name: "Bob"}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({name: "Alice"}, [:age], 30) == {name: "Alice", age: 30}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({}, [:user, :name], "Bob") == {user: {name: "Bob"}}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({}, [:foo, 0, :bar], 12) == {foo: [{bar: 12}]}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({items: [1, 2, 3]}, [:items, 1], 99) == {items: [1, 99, 3]}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({items: [1]}, [:items, 3], 99) == {items: [1, nil, nil, 99]}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch(nil, [:x], 1) == {x: 1}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (raise "Assertion failed" unless k_patch({}, [:a, :b, :c], 1) == {a: {b: {c: 1}}}; true) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (begin; (k_patch([], [:foo], 1)).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (begin; (k_patch([1, 2, 3], [:foo], 1)).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call(nil);
->(_) { def k_patch(d, p, v); return v if p.empty?; seg = p[0]; rest = p[1..]; next_default = rest.empty? ? nil : (rest[0].is_a?(Integer) ? [] : {}); if seg.is_a?(Integer); raise 'cannot patch array index on non-array' if !d.nil? && !d.is_a?(Array); arr = d.is_a?(Array) ? d.dup : []; arr[seg] = nil while arr.length <= seg; existing = arr[seg]; arr[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); arr; else; raise 'cannot patch object key on array' if d.is_a?(Array); obj = d.is_a?(Hash) ? d.dup : {}; existing = obj[seg]; obj[seg] = k_patch(existing.nil? ? next_default : existing, rest, v); obj end; end; (begin; (k_patch({foo: []}, [:foo, :bar], 1)).call; raise "Expected error but none thrown"; rescue => e; raise e if e.message == "Expected error but none thrown"; true; end) }.call(nil);
