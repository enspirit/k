(function(_) { function kEq(l, r) { if (Duration.isDuration(l) && Duration.isDuration(r)) return l.toMillis() === r.toMillis(); if (DateTime.isDateTime(l) && DateTime.isDateTime(r)) return l.toMillis() === r.toMillis(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function kMul(l, r) { if (Duration.isDuration(l)) return Duration.fromMillis(l.toMillis() * r); if (Duration.isDuration(r)) return Duration.fromMillis(r.toMillis() * l); return l * r; } return (function() { if (!(kEq([1, 2, 3].map((x) => kMul(x, 2)), [2, 4, 6]))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (Duration.isDuration(l) && Duration.isDuration(r)) return l.toMillis() === r.toMillis(); if (DateTime.isDateTime(l) && DateTime.isDateTime(r)) return l.toMillis() === r.toMillis(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } return (function() { if (!(kEq([1, 2, 3, 4].filter((x) => x > 2), [3, 4]))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kAdd(l, r) { if (DateTime.isDateTime(l) && Duration.isDuration(r)) return l.plus(r); if (Duration.isDuration(l) && DateTime.isDateTime(r)) return r.plus(l); if (Duration.isDuration(l) && Duration.isDuration(r)) return Duration.fromMillis(l.toMillis() + r.toMillis()); return l + r; } function kEq(l, r) { if (Duration.isDuration(l) && Duration.isDuration(r)) return l.toMillis() === r.toMillis(); if (DateTime.isDateTime(l) && DateTime.isDateTime(r)) return l.toMillis() === r.toMillis(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } return (function() { if (!(kEq([1, 2, 3].reduce((acc, x) => kAdd(acc, x), 0), 6))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { return (function() { if (!([1, 2, 3].some((x) => x > 2) == true)) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { return (function() { if (!([1, 2, 3].some((x) => x > 5) == false)) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { return (function() { if (!([1, 2, 3].every((x) => x > 0) == true)) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { return (function() { if (!([1, 2, 3].every((x) => x > 2) == false)) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kAdd(l, r) { if (DateTime.isDateTime(l) && Duration.isDuration(r)) return l.plus(r); if (Duration.isDuration(l) && DateTime.isDateTime(r)) return r.plus(l); if (Duration.isDuration(l) && Duration.isDuration(r)) return Duration.fromMillis(l.toMillis() + r.toMillis()); return l + r; } function kEq(l, r) { if (Duration.isDuration(l) && Duration.isDuration(r)) return l.toMillis() === r.toMillis(); if (DateTime.isDateTime(l) && DateTime.isDateTime(r)) return l.toMillis() === r.toMillis(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } return (function() { if (!(kEq(["a", "b", "c"].reduce((acc, x) => kAdd(acc, x), ""), "abc"))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (Duration.isDuration(l) && Duration.isDuration(r)) return l.toMillis() === r.toMillis(); if (DateTime.isDateTime(l) && DateTime.isDateTime(r)) return l.toMillis() === r.toMillis(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } function kMul(l, r) { if (Duration.isDuration(l)) return Duration.fromMillis(l.toMillis() * r); if (Duration.isDuration(r)) return Duration.fromMillis(r.toMillis() * l); return l * r; } return (function() { if (!(kEq([].map((x) => kMul(x, 2)), []))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kEq(l, r) { if (Duration.isDuration(l) && Duration.isDuration(r)) return l.toMillis() === r.toMillis(); if (DateTime.isDateTime(l) && DateTime.isDateTime(r)) return l.toMillis() === r.toMillis(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } return (function() { if (!(kEq([].filter((x) => x > 0), []))) throw new Error("Assertion failed"); return true; })(); })(null);
(function(_) { function kAdd(l, r) { if (DateTime.isDateTime(l) && Duration.isDuration(r)) return l.plus(r); if (Duration.isDuration(l) && DateTime.isDateTime(r)) return r.plus(l); if (Duration.isDuration(l) && Duration.isDuration(r)) return Duration.fromMillis(l.toMillis() + r.toMillis()); return l + r; } function kEq(l, r) { if (Duration.isDuration(l) && Duration.isDuration(r)) return l.toMillis() === r.toMillis(); if (DateTime.isDateTime(l) && DateTime.isDateTime(r)) return l.toMillis() === r.toMillis(); if (Array.isArray(l) && Array.isArray(r)) { if (l.length !== r.length) return false; for (let i = 0; i < l.length; i++) if (!kEq(l[i], r[i])) return false; return true; } if (typeof l === 'object' && typeof r === 'object' && l !== null && r !== null && !Array.isArray(l) && !Array.isArray(r)) { const keysL = Object.keys(l); const keysR = Object.keys(r); if (keysL.length !== keysR.length) return false; for (const key of keysL) if (!(key in r) || !kEq(l[key], r[key])) return false; return true; } return l == r; } return (function() { if (!(kEq((() => { const x = 10; return [1, 2, 3].map((y) => kAdd(x, y)); })(), [11, 12, 13]))) throw new Error("Assertion failed"); return true; })(); })(null);
